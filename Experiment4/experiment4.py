# -*- coding: utf-8 -*-
"""Experiment4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1f-cQrEkdQZBXtdPO4cjqBB3Eg0-HpPfm
"""

import cv2
from math import pi, exp, sqrt
import numpy as np
import os # to get list of all files in the input directory

def within_bounds(i, j, n):
    if (i<0) | (i>=n) | (j<0) | (j>=n):
        return False
    return True

def mean_filter_kernel(n):
    return [[1 for _ in range(n)] for __ in range(n)]

def median_filter(img, filter_size):
    img_size = len(img)
    new_img = [[0 for _ in range(img_size)] for __ in range(img_size)]

    for i in range(img_size):
        for j in range(img_size):
            pixel_vals = []
            for k in range(filter_size):
                for l in range(filter_size):
                    if within_bounds(i+k-int(filter_size/2), j+l-int(filter_size/2), img_size):
                        pixel_vals.append(img[i+k-int(filter_size/2)][j+l-int(filter_size/2)])
            pixel_vals.sort()
            new_img[i][j] = pixel_vals[int(len(pixel_vals)/2)]
    return new_img

def prewitt_filter_kernel(orientation):
    if orientation == 'H':
        return [
            [1,1,1],
            [0,0,0],
            [-1,-1,-1]
        ]
    if orientation == 'V':
        return [
            [1,0,-1],
            [1,0,-1],
            [1,0,-1]
        ]

def laplacian_filter_kernel():
    return [
            [-1,-1,-1],
            [-1,8,-1],
            [-1,-1,-1]
        ]

def sobel_filter_kernel(orientation):
    if orientation == 'H':
        return [
            [1,2,1],
            [0,0,0],
            [-1,-2,-1]
        ]
    if orientation == 'V':
        return [
            [1,0,-1],
            [2,0,-2],
            [1,0,-1]
        ]
    if orientation == 'D1':
        return [
            [0,1,2],
            [-1,0,1],
            [-2,-1,0]
        ]
    if orientation == 'D2':
        return [
            [2,1,0],
            [1,0,-1],
            [0,-1,-2]
        ]

def gaussian_filter_kernel(n, sigma):
    var = sigma*sigma
    kernel = [[0 for _ in range(n)] for __ in range(n)]
    for i in range(n):
        for j in range(n):
            x = i - int(n/2)
            y = j - int(n/2)
            kernel[i][j] = 1/(2*pi*var)*exp(-(x*x+y*y)/(2*var))
    return kernel

def convolve(img, kernel, no_int=False):
    kernel_size = len(kernel)
    img_size = len(img)
    new_img = [[0 for _ in range(img_size)] for __ in range(img_size)]

    for i in range(img_size):
        for j in range(img_size):
            num, den = 0, 0
            for k in range(kernel_size):
                for l in range(kernel_size):
                    if within_bounds(i-k+int(kernel_size/2), j-l+int(kernel_size/2), img_size):
                        num += kernel[k][l]*img[i-k+int(kernel_size/2)][j-l+int(kernel_size/2)] # elementwise multiply with flipped kernel
                        den += kernel[k][l]
            if den==0:
                new_img[i][j] = num
            else:
                if no_int:
                    new_img[i][j] = num/den
                else:
                    new_img[i][j] = int(num/den)
    return new_img

def gaussian_unblur(img):
    if not os.path.exists("unblur"):
        os.makedirs("unblur")
    kernel = gaussian_filter_kernel(3, 1)
    img_size = len(img)
    I_k = [[0 for _ in range(img_size)] for __ in range(img_size)]
    for i in range(img_size):
        for j in range(img_size):
            I_k[i][j] = img[i][j]
    diff, eps = float('inf'), 1e-1
    iter = 0
    while diff>eps:
        iter+=1
        print("Iteration:",iter)
        A = convolve(I_k, kernel, True)
        B = [[0 for _ in range(img_size)] for __ in range(img_size)]
        for i in range(img_size):
            for j in range(img_size):
                B[i][j] = img[i][j]/(A[i][j]+1e-30)

        C = convolve(B, kernel, True)
        I_nxt = [[0 for _ in range(img_size)] for __ in range(img_size)]
        cur_diff = 0
        for i in range(img_size):
            for j in range(img_size):
                I_nxt[i][j] = I_k[i][j]*C[i][j]
                cur_diff += abs(I_nxt[i][j]-I_k[i][j])
        cur_diff /= (img_size*img_size)    
        for i in range(img_size):
            for j in range(img_size):
                I_k[i][j] = I_nxt[i][j]
        diff = cur_diff
        print("Mean absolute change:",diff)
        new_img = np.array(I_k)
        cv2.imwrite("unblur/output_iter"+str(iter)+".jpg", new_img)
    return I_k

ch = input("1. Apply filter\n2. Gaussian unblur\nEnter choice: ")
if ch=='1':
    print("Available filters")
    print("mean, median, prewitt, laplacian, sobel, gaussian, lapgauss")
    filepath = input("Enter path for input images: ")
    filter = input("Enter filter to be used: ")
    orient=""
    if filter=="prewitt" or filter=="sobel":
            orient = input("Enter orientation: ")
    outpath = filter+"_"+orient

    for file in os.listdir(filepath+"/"):
        if file.endswith(".jpg"):
            print("Processing image:", file)
        if not os.path.exists(outpath):
            os.makedirs(outpath)
        img = cv2.imread(filepath+"/"+file)
        img = list(img[:,:,0]) # convert numpy array of grayscale intensity level to list
        if filter=='mean':
            kernel = mean_filter_kernel(3)
        elif filter=='median':
            new_img = median_filter(img, 3)
            new_img = np.array(new_img)
            cv2.imwrite(outpath+"/"+file, new_img)
            continue
        elif filter=='prewitt':
            kernel = prewitt_filter_kernel(orient)
        elif filter=='laplacian':
            kernel = laplacian_filter_kernel()
        elif filter=='sobel':
            kernel = sobel_filter_kernel(orient)
        elif filter=='gaussian':
            kernel = gaussian_filter_kernel(3,1)
        elif filter=='lapgauss':
            kernel = gaussian_filter_kernel(3,1)
            img = convolve(img,kernel)
            kernel = laplacian_filter_kernel()

        new_img = convolve(img, kernel)
        new_img = np.array(new_img)
        cv2.imwrite(outpath+"/"+file, new_img)
else:
    filepath = input("Enter path of file to be unblurred: ")
    img = cv2.imread(filepath)
    img = img[:,:,0]
    new_img = gaussian_unblur(img)

